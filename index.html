<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>贪吃蛇</title>
<style>
:root {
    --bg-color-light: #f0f0f0;
    --bg-color-dark: #1e1e1e;
    --snake-color: #4caf50;
    --snake-head-color: #ff5722;
    --food-color: #ffeb3b;
    --grid-color: #ccc;
    --text-color-light: #000;
    --text-color-dark: #fff;
}

@media (prefers-color-scheme: dark) {
    body {
        background: var(--bg-color-dark);
        color: var(--text-color-dark);
    }
}
@media (prefers-color-scheme: light) {
    body {
        background: var(--bg-color-light);
        color: var(--text-color-light);
    }
}

body {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
}

h1 {
    margin: 20px 0 10px;
}

#scoreboard {
    margin-bottom: 10px;
}

canvas {
    background: inherit;
    border: 2px solid #888;
    touch-action: none;
}

#instructions {
    margin-top: 10px;
    max-width: 400px;
    text-align: center;
    font-size: 14px;
    line-height: 1.5;
}
</style>
</head>
<body>

<h1>贪吃蛇</h1>
<div id="scoreboard">
    分数: <span id="score">0</span> | 最高分: <span id="highscore">0</span>
</div>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="instructions">
    点击画布四个区域控制蛇的方向。<br>
    蛇撞墙或撞到自己时游戏结束。<br>
    蛇头为橙色，其余为绿色。<br>
    游戏支持高刷新率显示器和平滑移动。
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const cellSize = 20; // 逻辑格子大小
const gridCount = canvas.width / cellSize;

let snake = [{x: 10, y: 10}];
let direction = {x: 0, y: 0};
let nextDirection = {x: 0, y: 0};
let food = {x: 15, y: 10};
let score = 0;
let highScore = localStorage.getItem('snakeHighScore') || 0;
let gameOver = false;
let moveProgress = 0;
const moveSpeed = 0.1; // 0.1～0.2 平滑程度，可调

document.getElementById('highscore').textContent = highScore;

// 绘制网格
function drawGrid() {
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color');
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= gridCount; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.stroke();
    }
}

// 绘制蛇和食物
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();

    // 绘制食物
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food-color');
    ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);

    // 绘制蛇
    snake.forEach((segment, index) => {
        ctx.fillStyle = index === 0 ? getComputedStyle(document.documentElement).getPropertyValue('--snake-head-color') : getComputedStyle(document.documentElement).getPropertyValue('--snake-color');
        ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
    });
}

// 检查碰撞
function checkCollision(pos) {
    if (pos.x < 0 || pos.x >= gridCount || pos.y < 0 || pos.y >= gridCount) return true;
    for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === pos.x && snake[i].y === pos.y) return true;
    }
    return false;
}

// 生成食物
function spawnFood() {
    let valid = false;
    while(!valid) {
        food.x = Math.floor(Math.random() * gridCount);
        food.y = Math.floor(Math.random() * gridCount);
        valid = !snake.some(seg => seg.x === food.x && seg.y === food.y);
    }
}

// 游戏主循环
function gameLoop() {
    if (!gameOver) {
        moveProgress += moveSpeed;
        if (moveProgress >= 1) {
            moveProgress = 0;
            direction = nextDirection;
            const newHead = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};

            if (checkCollision(newHead)) {
                gameOver = true;
                alert(`游戏结束！你的分数: ${score}`);
                if(score > highScore){
                    highScore = score;
                    localStorage.setItem('snakeHighScore', highScore);
                    document.getElementById('highscore').textContent = highScore;
                }
                return;
            }

            snake.unshift(newHead);
            if (newHead.x === food.x && newHead.y === food.y) {
                score++;
                document.getElementById('score').textContent = score;
                spawnFood();
            } else {
                snake.pop();
            }
        }

        // 平滑渲染蛇
        draw();
    }

    requestAnimationFrame(gameLoop);
}

// 控制方向
function handleDirection(x, y) {
    if (!gameOver) {
        if ((x !== -direction.x || y !== -direction.y)) {
            nextDirection = {x, y};
        }
    }
}

// 键盘控制
document.addEventListener('keydown', e => {
    if (gameOver) return;
    switch(e.key){
        case 'ArrowUp': handleDirection(0,-1); break;
        case 'ArrowDown': handleDirection(0,1); break;
        case 'ArrowLeft': handleDirection(-1,0); break;
        case 'ArrowRight': handleDirection(1,0); break;
    }
});

// 移动端点击控制
canvas.addEventListener('click', e => {
    if(gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (x < canvas.width/2 && y < canvas.height/2) handleDirection(0,-1); // 左上
    else if (x >= canvas.width/2 && y < canvas.height/2) handleDirection(1,0); // 右上
    else if (x < canvas.width/2 && y >= canvas.height/2) handleDirection(-1,0); // 左下
    else handleDirection(0,1); // 右下
});

// 页面加载后不自动开始游戏
draw();
</script>
</body>
</html>
